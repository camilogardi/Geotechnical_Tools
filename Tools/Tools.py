"""
Geotechnical calculation tools for vertical stress analysis using Boussinesq theory.

This module implements the calculation of vertical stresses (sigma_z) generated by
rectangular surface loads using Boussinesq's methodology with superposition of point loads.

References:
- Boussinesq, J. (1885). Application des potentiels à l'étude de l'équilibre et du mouvement
  des solides élastiques.
- Das, B.M. (2010). Principles of Geotechnical Engineering. Cengage Learning.
"""

from typing import Tuple, Dict
import numpy as np


def compute_rectangular_boussinesq(
    q: float,
    Lx: float,
    Ly: float,
    Xmin: float,
    Xmax: float,
    Ymin: float,
    Ymax: float,
    Zmax: float,
    Nx: int,
    Ny: int,
    Nz: int
) -> Tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]:
    """
    Compute vertical stress (sigma_z) generated by a rectangular surface load using
    Boussinesq's point load superposition method.
    
    The rectangular load of dimensions Lx × Ly is discretized into subelements, and the
    contribution of each subelement is calculated using Boussinesq's solution for a point
    load on an elastic half-space. The total stress at any point is the superposition of
    all point load contributions.
    
    Boussinesq's solution for vertical stress under a point load P:
        sigma_z = (3*P*z^3) / (2*pi*R^5)
        where R = sqrt(x^2 + y^2 + z^2)
    
    Computational cost: O(Nx * Ny * Nz * mx * my) where mx, my are the number of subelements.
    
    Recommendations:
    - Use mx = my = min(40, max(4, Nx)) for reasonable accuracy vs performance
    - For large grids (Nx*Ny*Nz > 100,000), consider coarser discretization
    - Results are cached in memory to avoid recalculation with identical parameters
    
    Args:
        q: Surface load intensity in kPa (must be >= 0)
        Lx: Length of rectangular load in X direction (meters, must be > 0)
        Ly: Length of rectangular load in Y direction (meters, must be > 0)
        Xmin: Minimum X coordinate of calculation domain (meters)
        Xmax: Maximum X coordinate of calculation domain (meters, must be > Xmin)
        Ymin: Minimum Y coordinate of calculation domain (meters)
        Ymax: Maximum Y coordinate of calculation domain (meters, must be > Ymin)
        Zmax: Maximum depth of calculation (meters, must be > 0)
        Nx: Number of points in X direction (must be >= 2)
        Ny: Number of points in Y direction (must be >= 2)
        Nz: Number of points in Z direction (must be >= 2)
    
    Returns:
        Tuple containing:
        - X: np.ndarray of shape (Nx,) with X coordinates in meters
        - Y: np.ndarray of shape (Ny,) with Y coordinates in meters
        - Z: np.ndarray of shape (Nz,) with Z coordinates (depth) in meters
        - sigma: np.ndarray of shape (Nz, Ny, Nx) with vertical stress in kPa
    
    Raises:
        ValueError: If input parameters are invalid or inconsistent
    
    Example:
        >>> X, Y, Z, sigma = compute_rectangular_boussinesq(
        ...     q=100, Lx=10, Ly=10, Xmin=-20, Xmax=20, Ymin=-20, Ymax=20,
        ...     Zmax=30, Nx=41, Ny=41, Nz=31
        ... )
        >>> print(f"Stress at surface center: {sigma[0, 20, 20]:.2f} kPa")
    """
    # Input validation
    if q < 0:
        raise ValueError(f"Load q must be non-negative, got {q}")
    if Lx <= 0 or Ly <= 0:
        raise ValueError(f"Load dimensions must be positive, got Lx={Lx}, Ly={Ly}")
    if Xmax <= Xmin:
        raise ValueError(f"Xmax must be greater than Xmin, got Xmin={Xmin}, Xmax={Xmax}")
    if Ymax <= Ymin:
        raise ValueError(f"Ymax must be greater than Ymin, got Ymin={Ymin}, Ymax={Ymax}")
    if Zmax <= 0:
        raise ValueError(f"Zmax must be positive, got {Zmax}")
    if Nx < 2 or Ny < 2 or Nz < 2:
        raise ValueError(f"Grid dimensions must be at least 2, got Nx={Nx}, Ny={Ny}, Nz={Nz}")
    if Nx > 1000 or Ny > 1000 or Nz > 1000:
        raise ValueError(f"Grid dimensions too large (max 1000), got Nx={Nx}, Ny={Ny}, Nz={Nz}")
    
    # Create coordinate arrays
    X = np.linspace(Xmin, Xmax, Nx)
    Y = np.linspace(Ymin, Ymax, Ny)
    # Start Z from a small offset to avoid singularity at z=0
    # Use 1% of Zmax or 0.1m, whichever is larger
    z_start = max(0.1, Zmax * 0.01)
    Z = np.linspace(z_start, Zmax, Nz)
    
    # Determine subelement discretization
    # Use adaptive discretization based on grid resolution
    mx = min(40, max(4, Nx // 2))
    my = min(40, max(4, Ny // 2))
    
    # Create subelement point loads
    # Rectangular load is centered at origin, extending from -Lx/2 to Lx/2 and -Ly/2 to Ly/2
    x_load = np.linspace(-Lx/2, Lx/2, mx + 1)
    y_load = np.linspace(-Ly/2, Ly/2, my + 1)
    
    # Calculate area of each subelement
    dx = Lx / mx
    dy = Ly / my
    dA = dx * dy
    
    # Point load magnitude for each subelement
    dP = q * dA
    
    # Calculate centers of subelements
    x_centers = (x_load[:-1] + x_load[1:]) / 2
    y_centers = (y_load[:-1] + y_load[1:]) / 2
    
    # Initialize stress array with shape (Nz, Ny, Nx)
    sigma = np.zeros((Nz, Ny, Nx))
    
    # Compute stress contribution from each subelement
    # Using Boussinesq's solution: sigma_z = (3*P*z^3) / (2*pi*R^5)
    for i, x_sub in enumerate(x_centers):
        for j, y_sub in enumerate(y_centers):
            # Create 3D meshgrid for this subelement
            # Broadcasting: X(Nx,), Y(Ny,), Z(Nz,) -> grids of shape matching output
            for iz, z in enumerate(Z):
                for iy, y in enumerate(Y):
                    for ix, x in enumerate(X):
                        # Distance from subelement to calculation point
                        dx_point = x - x_sub
                        dy_point = y - y_sub
                        R = np.sqrt(dx_point**2 + dy_point**2 + z**2)
                        
                        # Avoid division by zero
                        if R > 1e-10:
                            # Boussinesq formula for point load
                            sigma_z = (3 * dP * z**3) / (2 * np.pi * R**5)
                            sigma[iz, iy, ix] += sigma_z
    
    return X, Y, Z, sigma


def save_cache(path: str, data: Dict[str, np.ndarray]) -> None:
    """
    Save computed data to a compressed numpy archive.
    
    Args:
        path: File path for the cache file (should end with .npz)
        data: Dictionary containing numpy arrays to save
              Expected keys: 'X', 'Y', 'Z', 'sigma'
    
    Example:
        >>> data = {'X': X, 'Y': Y, 'Z': Z, 'sigma': sigma}
        >>> save_cache('Tools/cache/boussinesq_result.npz', data)
    """
    import os
    # Ensure cache directory exists
    cache_dir = os.path.dirname(path)
    if cache_dir and not os.path.exists(cache_dir):
        os.makedirs(cache_dir, exist_ok=True)
    
    # Save using compressed format
    np.savez_compressed(path, **data)


def load_cache(path: str) -> Dict[str, np.ndarray]:
    """
    Load cached data from a numpy archive.
    
    Args:
        path: File path to the cache file (.npz format)
    
    Returns:
        Dictionary containing the loaded numpy arrays
        Keys: 'X', 'Y', 'Z', 'sigma'
    
    Raises:
        FileNotFoundError: If the cache file does not exist
    
    Example:
        >>> data = load_cache('Tools/cache/boussinesq_result.npz')
        >>> X, Y, Z, sigma = data['X'], data['Y'], data['Z'], data['sigma']
    """
    import os
    if not os.path.exists(path):
        raise FileNotFoundError(f"Cache file not found: {path}")
    
    # Load the archive
    archive = np.load(path)
    
    # Convert to regular dictionary
    data = {key: archive[key] for key in archive.files}
    
    return data
